// Generated by go-wayland-scanner
// https://github.com/rajveermalviya/go-wayland/cmd/go-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/d10d18f3d49374d2e3eb96d63511f32795aab5f7/unstable/xdg-decoration/xdg-decoration-unstable-v1.xml
//
// XdgDecorationUnstableV1 Protocol Copyright:
//
// Copyright Â© 2018 Simon Ser
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice (including the next
// paragraph) shall be included in all copies or substantial portions of the
// Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

package xdg_decoration

import (
	"sync"

	"github.com/rajveermalviya/go-wayland/client"
	xdg_shell "github.com/rajveermalviya/go-wayland/stable/xdg-shell"
)

// ZxdgDecorationManagerV1 : window decoration manager
//
// This interface allows a compositor to announce support for server-side
// decorations.
//
// A window decoration is a set of window controls as deemed appropriate by
// the party managing them, such as user interface components used to move,
// resize and change a window's state.
//
// A client can use this protocol to request being decorated by a supporting
// compositor.
//
// If compositor and client do not negotiate the use of a server-side
// decoration using this protocol, clients continue to self-decorate as they
// see fit.
//
// Warning! The protocol described in this file is experimental and
// backward incompatible changes may be made. Backward compatible changes
// may be added together with the corresponding interface version bump.
// Backward incompatible changes are done by bumping the version number in
// the protocol and interface names and resetting the interface version.
// Once the protocol is to be declared stable, the 'z' prefix and the
// version number in the protocol and interface names are removed and the
// interface version number is reset.
type ZxdgDecorationManagerV1 struct {
	client.BaseProxy
	mu sync.RWMutex
}

// NewZxdgDecorationManagerV1 : window decoration manager
//
// This interface allows a compositor to announce support for server-side
// decorations.
//
// A window decoration is a set of window controls as deemed appropriate by
// the party managing them, such as user interface components used to move,
// resize and change a window's state.
//
// A client can use this protocol to request being decorated by a supporting
// compositor.
//
// If compositor and client do not negotiate the use of a server-side
// decoration using this protocol, clients continue to self-decorate as they
// see fit.
//
// Warning! The protocol described in this file is experimental and
// backward incompatible changes may be made. Backward compatible changes
// may be added together with the corresponding interface version bump.
// Backward incompatible changes are done by bumping the version number in
// the protocol and interface names and resetting the interface version.
// Once the protocol is to be declared stable, the 'z' prefix and the
// version number in the protocol and interface names are removed and the
// interface version number is reset.
func NewZxdgDecorationManagerV1(ctx *client.Context) *ZxdgDecorationManagerV1 {
	zxdgDecorationManagerV1 := &ZxdgDecorationManagerV1{}
	ctx.Register(zxdgDecorationManagerV1)
	return zxdgDecorationManagerV1
}

// Destroy : destroy the decoration manager object
//
// Destroy the decoration manager. This doesn't destroy objects created
// with the manager.
//
func (i *ZxdgDecorationManagerV1) Destroy() error {
	err := i.Context().SendRequest(i, 0)
	return err
}

// GetToplevelDecoration : create a new toplevel decoration object
//
// Create a new decoration object associated with the given toplevel.
//
// Creating an xdg_toplevel_decoration from an xdg_toplevel which has a
// buffer attached or committed is a client error, and any attempts by a
// client to attach or manipulate a buffer prior to the first
// xdg_toplevel_decoration.configure event must also be treated as
// errors.
//
func (i *ZxdgDecorationManagerV1) GetToplevelDecoration(toplevel *xdg_shell.XdgToplevel) (*ZxdgToplevelDecorationV1, error) {
	id := NewZxdgToplevelDecorationV1(i.Context())
	err := i.Context().SendRequest(i, 1, id, toplevel)
	return id, err
}

// ZxdgToplevelDecorationV1 : decoration object for a toplevel surface
//
// The decoration object allows the compositor to toggle server-side window
// decorations for a toplevel surface. The client can request to switch to
// another mode.
//
// The xdg_toplevel_decoration object must be destroyed before its
// xdg_toplevel.
type ZxdgToplevelDecorationV1 struct {
	client.BaseProxy
	mu                sync.RWMutex
	configureHandlers []ZxdgToplevelDecorationV1ConfigureHandler
}

// NewZxdgToplevelDecorationV1 : decoration object for a toplevel surface
//
// The decoration object allows the compositor to toggle server-side window
// decorations for a toplevel surface. The client can request to switch to
// another mode.
//
// The xdg_toplevel_decoration object must be destroyed before its
// xdg_toplevel.
func NewZxdgToplevelDecorationV1(ctx *client.Context) *ZxdgToplevelDecorationV1 {
	zxdgToplevelDecorationV1 := &ZxdgToplevelDecorationV1{}
	ctx.Register(zxdgToplevelDecorationV1)
	return zxdgToplevelDecorationV1
}

// Destroy : destroy the decoration object
//
// Switch back to a mode without any server-side decorations at the next
// commit.
//
func (i *ZxdgToplevelDecorationV1) Destroy() error {
	err := i.Context().SendRequest(i, 0)
	return err
}

// SetMode : set the decoration mode
//
// Set the toplevel surface decoration mode. This informs the compositor
// that the client prefers the provided decoration mode.
//
// After requesting a decoration mode, the compositor will respond by
// emitting an xdg_surface.configure event. The client should then update
// its content, drawing it without decorations if the received mode is
// server-side decorations. The client must also acknowledge the configure
// when committing the new content (see xdg_surface.ack_configure).
//
// The compositor can decide not to use the client's mode and enforce a
// different mode instead.
//
// Clients whose decoration mode depend on the xdg_toplevel state may send
// a set_mode request in response to an xdg_surface.configure event and wait
// for the next xdg_surface.configure event to prevent unwanted state.
// Such clients are responsible for preventing configure loops and must
// make sure not to send multiple successive set_mode requests with the
// same decoration mode.
//
// mode: the decoration mode
func (i *ZxdgToplevelDecorationV1) SetMode(mode uint32) error {
	err := i.Context().SendRequest(i, 1, mode)
	return err
}

// UnsetMode : unset the decoration mode
//
// Unset the toplevel surface decoration mode. This informs the compositor
// that the client doesn't prefer a particular decoration mode.
//
// This request has the same semantics as set_mode.
//
func (i *ZxdgToplevelDecorationV1) UnsetMode() error {
	err := i.Context().SendRequest(i, 2)
	return err
}

// ZxdgToplevelDecorationV1Error :
const (
	// ZxdgToplevelDecorationV1ErrorUnconfiguredBuffer : xdg_toplevel has a buffer attached before configure
	ZxdgToplevelDecorationV1ErrorUnconfiguredBuffer = 0
	// ZxdgToplevelDecorationV1ErrorAlreadyConstructed : xdg_toplevel already has a decoration object
	ZxdgToplevelDecorationV1ErrorAlreadyConstructed = 1
	// ZxdgToplevelDecorationV1ErrorOrphaned : xdg_toplevel destroyed before the decoration object
	ZxdgToplevelDecorationV1ErrorOrphaned = 2
)

// ZxdgToplevelDecorationV1Mode : window decoration modes
//
// These values describe window decoration modes.
const (
	// ZxdgToplevelDecorationV1ModeClientSide : no server-side window decoration
	ZxdgToplevelDecorationV1ModeClientSide = 1
	// ZxdgToplevelDecorationV1ModeServerSide : server-side window decoration
	ZxdgToplevelDecorationV1ModeServerSide = 2
)

// ZxdgToplevelDecorationV1ConfigureEvent : suggest a surface change
//
// The configure event asks the client to change its decoration mode. The
// configured state should not be applied immediately. Clients must send an
// ack_configure in response to this event. See xdg_surface.configure and
// xdg_surface.ack_configure for details.
//
// A configure event can be sent at any time. The specified mode must be
// obeyed by the client.
type ZxdgToplevelDecorationV1ConfigureEvent struct {
	Mode uint32
}

type ZxdgToplevelDecorationV1ConfigureHandler interface {
	HandleZxdgToplevelDecorationV1Configure(ZxdgToplevelDecorationV1ConfigureEvent)
}

// AddConfigureHandler : suggest a surface change
//
// The configure event asks the client to change its decoration mode. The
// configured state should not be applied immediately. Clients must send an
// ack_configure in response to this event. See xdg_surface.configure and
// xdg_surface.ack_configure for details.
//
// A configure event can be sent at any time. The specified mode must be
// obeyed by the client.
func (i *ZxdgToplevelDecorationV1) AddConfigureHandler(h ZxdgToplevelDecorationV1ConfigureHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.configureHandlers = append(i.configureHandlers, h)
	i.mu.Unlock()
}

func (i *ZxdgToplevelDecorationV1) RemoveConfigureHandler(h ZxdgToplevelDecorationV1ConfigureHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.configureHandlers {
		if e == h {
			i.configureHandlers = append(i.configureHandlers[:j], i.configureHandlers[j+1:]...)
			break
		}
	}
}

func (i *ZxdgToplevelDecorationV1) Dispatch(event *client.Event) {
	switch event.Opcode {
	case 0:
		i.mu.RLock()
		if len(i.configureHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZxdgToplevelDecorationV1ConfigureEvent{
			Mode: event.Uint32(),
		}

		i.mu.RLock()
		for _, h := range i.configureHandlers {
			i.mu.RUnlock()

			h.HandleZxdgToplevelDecorationV1Configure(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	}
}
