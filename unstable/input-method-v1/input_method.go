// package input_method acts as a client for the input_method_unstable_v1 wayland protocol.

// generated by wl-scanner
// https://github.com/dkolbly/wl-scanner
// from: input-method-unstable-v1.xml
// on 2021-03-28 12:39:56 +0200

package inputmethod

import (
	"github.com/neurlang/wayland/wl"
	"sync"
)

type ZwpInputMethodContextV1SurroundingTextEvent struct {
	Text   string
	Cursor uint32
	Anchor uint32
}

type ZwpInputMethodContextV1SurroundingTextHandler interface {
	HandleZwpInputMethodContextV1SurroundingText(ZwpInputMethodContextV1SurroundingTextEvent)
}

func (p *ZwpInputMethodContextV1) AddSurroundingTextHandler(h ZwpInputMethodContextV1SurroundingTextHandler) {
	if h != nil {
		p.mu.Lock()
		p.surroundingTextHandlers = append(p.surroundingTextHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ZwpInputMethodContextV1) RemoveSurroundingTextHandler(h ZwpInputMethodContextV1SurroundingTextHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.surroundingTextHandlers {
		if e == h {
			p.surroundingTextHandlers = append(p.surroundingTextHandlers[:i], p.surroundingTextHandlers[i+1:]...)
			break
		}
	}
}

type ZwpInputMethodContextV1ResetEvent struct {
}

type ZwpInputMethodContextV1ResetHandler interface {
	HandleZwpInputMethodContextV1Reset(ZwpInputMethodContextV1ResetEvent)
}

func (p *ZwpInputMethodContextV1) AddResetHandler(h ZwpInputMethodContextV1ResetHandler) {
	if h != nil {
		p.mu.Lock()
		p.resetHandlers = append(p.resetHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ZwpInputMethodContextV1) RemoveResetHandler(h ZwpInputMethodContextV1ResetHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.resetHandlers {
		if e == h {
			p.resetHandlers = append(p.resetHandlers[:i], p.resetHandlers[i+1:]...)
			break
		}
	}
}

type ZwpInputMethodContextV1ContentTypeEvent struct {
	Hint    uint32
	Purpose uint32
}

type ZwpInputMethodContextV1ContentTypeHandler interface {
	HandleZwpInputMethodContextV1ContentType(ZwpInputMethodContextV1ContentTypeEvent)
}

func (p *ZwpInputMethodContextV1) AddContentTypeHandler(h ZwpInputMethodContextV1ContentTypeHandler) {
	if h != nil {
		p.mu.Lock()
		p.contentTypeHandlers = append(p.contentTypeHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ZwpInputMethodContextV1) RemoveContentTypeHandler(h ZwpInputMethodContextV1ContentTypeHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.contentTypeHandlers {
		if e == h {
			p.contentTypeHandlers = append(p.contentTypeHandlers[:i], p.contentTypeHandlers[i+1:]...)
			break
		}
	}
}

type ZwpInputMethodContextV1InvokeActionEvent struct {
	Button uint32
	Index  uint32
}

type ZwpInputMethodContextV1InvokeActionHandler interface {
	HandleZwpInputMethodContextV1InvokeAction(ZwpInputMethodContextV1InvokeActionEvent)
}

func (p *ZwpInputMethodContextV1) AddInvokeActionHandler(h ZwpInputMethodContextV1InvokeActionHandler) {
	if h != nil {
		p.mu.Lock()
		p.invokeActionHandlers = append(p.invokeActionHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ZwpInputMethodContextV1) RemoveInvokeActionHandler(h ZwpInputMethodContextV1InvokeActionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.invokeActionHandlers {
		if e == h {
			p.invokeActionHandlers = append(p.invokeActionHandlers[:i], p.invokeActionHandlers[i+1:]...)
			break
		}
	}
}

type ZwpInputMethodContextV1CommitStateEvent struct {
	Serial uint32
}

type ZwpInputMethodContextV1CommitStateHandler interface {
	HandleZwpInputMethodContextV1CommitState(ZwpInputMethodContextV1CommitStateEvent)
}

func (p *ZwpInputMethodContextV1) AddCommitStateHandler(h ZwpInputMethodContextV1CommitStateHandler) {
	if h != nil {
		p.mu.Lock()
		p.commitStateHandlers = append(p.commitStateHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ZwpInputMethodContextV1) RemoveCommitStateHandler(h ZwpInputMethodContextV1CommitStateHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.commitStateHandlers {
		if e == h {
			p.commitStateHandlers = append(p.commitStateHandlers[:i], p.commitStateHandlers[i+1:]...)
			break
		}
	}
}

type ZwpInputMethodContextV1PreferredLanguageEvent struct {
	Language string
}

type ZwpInputMethodContextV1PreferredLanguageHandler interface {
	HandleZwpInputMethodContextV1PreferredLanguage(ZwpInputMethodContextV1PreferredLanguageEvent)
}

func (p *ZwpInputMethodContextV1) AddPreferredLanguageHandler(h ZwpInputMethodContextV1PreferredLanguageHandler) {
	if h != nil {
		p.mu.Lock()
		p.preferredLanguageHandlers = append(p.preferredLanguageHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ZwpInputMethodContextV1) RemovePreferredLanguageHandler(h ZwpInputMethodContextV1PreferredLanguageHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.preferredLanguageHandlers {
		if e == h {
			p.preferredLanguageHandlers = append(p.preferredLanguageHandlers[:i], p.preferredLanguageHandlers[i+1:]...)
			break
		}
	}
}

func (p *ZwpInputMethodContextV1) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.surroundingTextHandlers) > 0 {
			ev := ZwpInputMethodContextV1SurroundingTextEvent{}
			ev.Text = event.String()
			ev.Cursor = event.Uint32()
			ev.Anchor = event.Uint32()
			p.mu.RLock()
			for _, h := range p.surroundingTextHandlers {
				h.HandleZwpInputMethodContextV1SurroundingText(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.resetHandlers) > 0 {
			ev := ZwpInputMethodContextV1ResetEvent{}
			p.mu.RLock()
			for _, h := range p.resetHandlers {
				h.HandleZwpInputMethodContextV1Reset(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.contentTypeHandlers) > 0 {
			ev := ZwpInputMethodContextV1ContentTypeEvent{}
			ev.Hint = event.Uint32()
			ev.Purpose = event.Uint32()
			p.mu.RLock()
			for _, h := range p.contentTypeHandlers {
				h.HandleZwpInputMethodContextV1ContentType(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.invokeActionHandlers) > 0 {
			ev := ZwpInputMethodContextV1InvokeActionEvent{}
			ev.Button = event.Uint32()
			ev.Index = event.Uint32()
			p.mu.RLock()
			for _, h := range p.invokeActionHandlers {
				h.HandleZwpInputMethodContextV1InvokeAction(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.commitStateHandlers) > 0 {
			ev := ZwpInputMethodContextV1CommitStateEvent{}
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.commitStateHandlers {
				h.HandleZwpInputMethodContextV1CommitState(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.preferredLanguageHandlers) > 0 {
			ev := ZwpInputMethodContextV1PreferredLanguageEvent{}
			ev.Language = event.String()
			p.mu.RLock()
			for _, h := range p.preferredLanguageHandlers {
				h.HandleZwpInputMethodContextV1PreferredLanguage(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type ZwpInputMethodContextV1 struct {
	wl.BaseProxy
	mu                        sync.RWMutex
	surroundingTextHandlers   []ZwpInputMethodContextV1SurroundingTextHandler
	resetHandlers             []ZwpInputMethodContextV1ResetHandler
	contentTypeHandlers       []ZwpInputMethodContextV1ContentTypeHandler
	invokeActionHandlers      []ZwpInputMethodContextV1InvokeActionHandler
	commitStateHandlers       []ZwpInputMethodContextV1CommitStateHandler
	preferredLanguageHandlers []ZwpInputMethodContextV1PreferredLanguageHandler
}

func NewZwpInputMethodContextV1(ctx *wl.Context) *ZwpInputMethodContextV1 {
	ret := new(ZwpInputMethodContextV1)
	ctx.Register(ret)
	return ret
}

// Destroy will .
func (p *ZwpInputMethodContextV1) Destroy() error {
	return p.Context().SendRequest(p, 0)
}

// CommitString will commit string.
//
// Send the commit string text for insertion to the application.
//
// The text to commit could be either just a single character after a key
// press or the result of some composing (pre-edit). It could be also an
// empty text when some text should be removed (see
// delete_surrounding_text) or when the input cursor should be moved (see
// cursor_position).
//
// Any previously set composing text will be removed.
func (p *ZwpInputMethodContextV1) CommitString(serial uint32, text string) error {
	return p.Context().SendRequest(p, 1, serial, text)
}

// PreeditString will pre-edit string.
//
// Send the pre-edit string text to the application text input.
//
// The commit text can be used to replace the pre-edit text on reset (for
// example on unfocus).
//
// Previously sent preedit_style and preedit_cursor requests are also
// processed by the text_input.
func (p *ZwpInputMethodContextV1) PreeditString(serial uint32, text string, commit string) error {
	return p.Context().SendRequest(p, 2, serial, text, commit)
}

// PreeditStyling will pre-edit styling.
//
// Set the styling information on composing text. The style is applied for
// length in bytes from index relative to the beginning of
// the composing text (as byte offset). Multiple styles can
// be applied to a composing text.
//
// This request should be sent before sending a preedit_string request.
func (p *ZwpInputMethodContextV1) PreeditStyling(index uint32, length uint32, style uint32) error {
	return p.Context().SendRequest(p, 3, index, length, style)
}

// PreeditCursor will pre-edit cursor.
//
// Set the cursor position inside the composing text (as byte offset)
// relative to the start of the composing text.
//
// When index is negative no cursor should be displayed.
//
// This request should be sent before sending a preedit_string request.
func (p *ZwpInputMethodContextV1) PreeditCursor(index int32) error {
	return p.Context().SendRequest(p, 4, index)
}

// DeleteSurroundingText will delete text.
//
// Remove the surrounding text.
//
// This request will be handled on the text_input side directly following
// a commit_string request.
func (p *ZwpInputMethodContextV1) DeleteSurroundingText(index int32, length uint32) error {
	return p.Context().SendRequest(p, 5, index, length)
}

// CursorPosition will set cursor to a new position.
//
// Set the cursor and anchor to a new position. Index is the new cursor
// position in bytes (when >= 0 this is relative to the end of the inserted text,
// otherwise it is relative to the beginning of the inserted text). Anchor is
// the new anchor position in bytes (when >= 0 this is relative to the end of the
// inserted text, otherwise it is relative to the beginning of the inserted
// text). When there should be no selected text, anchor should be the same
// as index.
//
// This request will be handled on the text_input side directly following
// a commit_string request.
func (p *ZwpInputMethodContextV1) CursorPosition(index int32, anchor int32) error {
	return p.Context().SendRequest(p, 6, index, anchor)
}

// ModifiersMap will .
func (p *ZwpInputMethodContextV1) ModifiersMap(map_ []int32) error {
	return p.Context().SendRequest(p, 7, map_)
}

// Keysym will keysym.
//
// Notify when a key event was sent. Key events should not be used for
// normal text input operations, which should be done with commit_string,
// delete_surrounding_text, etc. The key event follows the wl_keyboard key
// event convention. Sym is an XKB keysym, state is a wl_keyboard key_state.
func (p *ZwpInputMethodContextV1) Keysym(serial uint32, time uint32, sym uint32, state uint32, modifiers uint32) error {
	return p.Context().SendRequest(p, 8, serial, time, sym, state, modifiers)
}

// GrabKeyboard will grab hardware keyboard.
//
// Allow an input method to receive hardware keyboard input and process
// key events to generate text events (with pre-edit) over the wire. This
// allows input methods which compose multiple key events for inputting
// text like it is done for CJK languages.
func (p *ZwpInputMethodContextV1) GrabKeyboard() (*wl.Keyboard, error) {
	ret := wl.NewKeyboard(p.Context())
	return ret, p.Context().SendRequest(p, 9, wl.Proxy(ret))
}

// Key will forward key event.
//
// Forward a wl_keyboard::key event to the client that was not processed
// by the input method itself. Should be used when filtering key events
// with grab_keyboard.  The arguments should be the ones from the
// wl_keyboard::key event.
//
// For generating custom key events use the keysym request instead.
func (p *ZwpInputMethodContextV1) Key(serial uint32, time uint32, key uint32, state uint32) error {
	return p.Context().SendRequest(p, 10, serial, time, key, state)
}

// Modifiers will forward modifiers event.
//
// Forward a wl_keyboard::modifiers event to the client that was not
// processed by the input method itself.  Should be used when filtering
// key events with grab_keyboard. The arguments should be the ones
// from the wl_keyboard::modifiers event.
func (p *ZwpInputMethodContextV1) Modifiers(serial uint32, modsDepressed uint32, modsLatched uint32, modsLocked uint32, group uint32) error {
	return p.Context().SendRequest(p, 11, serial, modsDepressed, modsLatched, modsLocked, group)
}

// Language will .
func (p *ZwpInputMethodContextV1) Language(serial uint32, language string) error {
	return p.Context().SendRequest(p, 12, serial, language)
}

// TextDirection will .
func (p *ZwpInputMethodContextV1) TextDirection(serial uint32, direction uint32) error {
	return p.Context().SendRequest(p, 13, serial, direction)
}

type ZwpInputMethodV1ActivateEvent struct {
	Id *ZwpInputMethodContextV1
}

type ZwpInputMethodV1ActivateHandler interface {
	HandleZwpInputMethodV1Activate(ZwpInputMethodV1ActivateEvent)
}

func (p *ZwpInputMethodV1) AddActivateHandler(h ZwpInputMethodV1ActivateHandler) {
	if h != nil {
		p.mu.Lock()
		p.activateHandlers = append(p.activateHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ZwpInputMethodV1) RemoveActivateHandler(h ZwpInputMethodV1ActivateHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.activateHandlers {
		if e == h {
			p.activateHandlers = append(p.activateHandlers[:i], p.activateHandlers[i+1:]...)
			break
		}
	}
}

type ZwpInputMethodV1DeactivateEvent struct {
	Context *ZwpInputMethodContextV1
}

type ZwpInputMethodV1DeactivateHandler interface {
	HandleZwpInputMethodV1Deactivate(ZwpInputMethodV1DeactivateEvent)
}

func (p *ZwpInputMethodV1) AddDeactivateHandler(h ZwpInputMethodV1DeactivateHandler) {
	if h != nil {
		p.mu.Lock()
		p.deactivateHandlers = append(p.deactivateHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ZwpInputMethodV1) RemoveDeactivateHandler(h ZwpInputMethodV1DeactivateHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.deactivateHandlers {
		if e == h {
			p.deactivateHandlers = append(p.deactivateHandlers[:i], p.deactivateHandlers[i+1:]...)
			break
		}
	}
}

func (p *ZwpInputMethodV1) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.activateHandlers) > 0 {
			ev := ZwpInputMethodV1ActivateEvent{}
			ev.Id = event.Proxy(p.Context()).(*ZwpInputMethodContextV1)
			p.mu.RLock()
			for _, h := range p.activateHandlers {
				h.HandleZwpInputMethodV1Activate(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.deactivateHandlers) > 0 {
			ev := ZwpInputMethodV1DeactivateEvent{}
			ev.Context = event.Proxy(p.Context()).(*ZwpInputMethodContextV1)
			p.mu.RLock()
			for _, h := range p.deactivateHandlers {
				h.HandleZwpInputMethodV1Deactivate(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type ZwpInputMethodV1 struct {
	wl.BaseProxy
	mu                 sync.RWMutex
	activateHandlers   []ZwpInputMethodV1ActivateHandler
	deactivateHandlers []ZwpInputMethodV1DeactivateHandler
}

func NewZwpInputMethodV1(ctx *wl.Context) *ZwpInputMethodV1 {
	ret := new(ZwpInputMethodV1)
	ctx.Register(ret)
	return ret
}

type ZwpInputPanelV1 struct {
	wl.BaseProxy
}

func NewZwpInputPanelV1(ctx *wl.Context) *ZwpInputPanelV1 {
	ret := new(ZwpInputPanelV1)
	ctx.Register(ret)
	return ret
}

// GetInputPanelSurface will .
func (p *ZwpInputPanelV1) GetInputPanelSurface(surface *wl.Surface) (*ZwpInputPanelSurfaceV1, error) {
	ret := NewZwpInputPanelSurfaceV1(p.Context())
	return ret, p.Context().SendRequest(p, 0, wl.Proxy(ret), surface)
}

type ZwpInputPanelSurfaceV1 struct {
	wl.BaseProxy
}

func NewZwpInputPanelSurfaceV1(ctx *wl.Context) *ZwpInputPanelSurfaceV1 {
	ret := new(ZwpInputPanelSurfaceV1)
	ctx.Register(ret)
	return ret
}

// SetToplevel will set the surface type as a keyboard.
//
// Set the input_panel_surface type to keyboard.
//
// A keyboard surface is only shown when a text input is active.
func (p *ZwpInputPanelSurfaceV1) SetToplevel(output *wl.Output, position uint32) error {
	return p.Context().SendRequest(p, 0, output, position)
}

// SetOverlayPanel will set the surface type as an overlay panel.
//
// Set the input_panel_surface to be an overlay panel.
//
// This is shown near the input cursor above the application window when
// a text input is active.
func (p *ZwpInputPanelSurfaceV1) SetOverlayPanel() error {
	return p.Context().SendRequest(p, 1)
}

const (
	ZwpInputPanelSurfaceV1PositionCenterBottom = 0
)
