// This file is autogenerated from: ../../xdg/xdg-shell.xml
// Do not edit

// Package xdg implements the xdg_shell protocol
package xdg

import (
	"sync"
)

// WmBaseErrorRole means given wl_surface has another role
const WmBaseErrorRole = 0

// WmBaseErrorDefunctSurfaces means xdg_wm_base was destroyed before children
const WmBaseErrorDefunctSurfaces = 1

// WmBaseErrorNotTheTopmostPopup means the client tried to map or destroy a non-topmost popup
const WmBaseErrorNotTheTopmostPopup = 2

// WmBaseErrorInvalidPopupParent means the client specified an invalid popup parent surface
const WmBaseErrorInvalidPopupParent = 3

// WmBaseErrorInvalidSurfaceState means the client provided an invalid surface state
const WmBaseErrorInvalidSurfaceState = 4

// WmBaseErrorInvalidPositioner means the client provided an invalid positioner
const WmBaseErrorInvalidPositioner = 5

// WmBaseErrorUnresponsive means the client didnâ€™t respond to a ping event in time
const WmBaseErrorUnresponsive = 6

// PositionerErrorInvalidInput means invalid input provided
const PositionerErrorInvalidInput = 0

// PositionerAnchorNone
const PositionerAnchorNone = 0

// PositionerAnchorTop
const PositionerAnchorTop = 1

// PositionerAnchorBottom
const PositionerAnchorBottom = 2

// PositionerAnchorLeft
const PositionerAnchorLeft = 3

// PositionerAnchorRight
const PositionerAnchorRight = 4

// PositionerAnchorTopLeft
const PositionerAnchorTopLeft = 5

// PositionerAnchorBottomLeft
const PositionerAnchorBottomLeft = 6

// PositionerAnchorTopRight
const PositionerAnchorTopRight = 7

// PositionerAnchorBottomRight
const PositionerAnchorBottomRight = 8

// PositionerGravityNone
const PositionerGravityNone = 0

// PositionerGravityTop
const PositionerGravityTop = 1

// PositionerGravityBottom
const PositionerGravityBottom = 2

// PositionerGravityLeft
const PositionerGravityLeft = 3

// PositionerGravityRight
const PositionerGravityRight = 4

// PositionerGravityTopLeft
const PositionerGravityTopLeft = 5

// PositionerGravityBottomLeft
const PositionerGravityBottomLeft = 6

// PositionerGravityTopRight
const PositionerGravityTopRight = 7

// PositionerGravityBottomRight
const PositionerGravityBottomRight = 8

// PositionerConstraintAdjustmentNone
const PositionerConstraintAdjustmentNone = 0

// PositionerConstraintAdjustmentSlideX
const PositionerConstraintAdjustmentSlideX = 1

// PositionerConstraintAdjustmentSlideY
const PositionerConstraintAdjustmentSlideY = 2

// PositionerConstraintAdjustmentFlipX
const PositionerConstraintAdjustmentFlipX = 4

// PositionerConstraintAdjustmentFlipY
const PositionerConstraintAdjustmentFlipY = 8

// PositionerConstraintAdjustmentResizeX
const PositionerConstraintAdjustmentResizeX = 16

// PositionerConstraintAdjustmentResizeY
const PositionerConstraintAdjustmentResizeY = 32

// SurfaceErrorNotConstructed means Surface was not fully constructed
const SurfaceErrorNotConstructed = 1

// SurfaceErrorAlreadyConstructed means Surface was already constructed
const SurfaceErrorAlreadyConstructed = 2

// SurfaceErrorUnconfiguredBuffer means Attaching a buffer to an unconfigured surface
const SurfaceErrorUnconfiguredBuffer = 3

// SurfaceErrorInvalidSerial means Invalid serial number when acking a configure event
const SurfaceErrorInvalidSerial = 4

// SurfaceErrorInvalidSize means Width or height was zero or negative
const SurfaceErrorInvalidSize = 5

// SurfaceErrorDefunctRoleObject means Surface was destroyed before its role object
const SurfaceErrorDefunctRoleObject = 6

// ToplevelErrorInvalidResizeEdge means provided value is    not a valid variant of the resize_edge enum
const ToplevelErrorInvalidResizeEdge = 0

// ToplevelErrorInvalidParent means invalid parent toplevel
const ToplevelErrorInvalidParent = 1

// ToplevelErrorInvalidSize means client provided an invalid min or max size
const ToplevelErrorInvalidSize = 2

// ToplevelResizeEdgeNone
const ToplevelResizeEdgeNone = 0

// ToplevelResizeEdgeTop
const ToplevelResizeEdgeTop = 1

// ToplevelResizeEdgeBottom
const ToplevelResizeEdgeBottom = 2

// ToplevelResizeEdgeLeft
const ToplevelResizeEdgeLeft = 4

// ToplevelResizeEdgeTopLeft
const ToplevelResizeEdgeTopLeft = 5

// ToplevelResizeEdgeBottomLeft
const ToplevelResizeEdgeBottomLeft = 6

// ToplevelResizeEdgeRight
const ToplevelResizeEdgeRight = 8

// ToplevelResizeEdgeTopRight
const ToplevelResizeEdgeTopRight = 9

// ToplevelResizeEdgeBottomRight
const ToplevelResizeEdgeBottomRight = 10

// ToplevelStateMaximized means the surface is maximized
const ToplevelStateMaximized = 1

// ToplevelStateFullscreen means the surface is fullscreen
const ToplevelStateFullscreen = 2

// ToplevelStateResizing means the surface is being resized
const ToplevelStateResizing = 3

// ToplevelStateActivated means the surface is now activated
const ToplevelStateActivated = 4

// ToplevelStateTiledLeft
const ToplevelStateTiledLeft = 5

// ToplevelStateTiledRight
const ToplevelStateTiledRight = 6

// ToplevelStateTiledTop
const ToplevelStateTiledTop = 7

// ToplevelStateTiledBottom
const ToplevelStateTiledBottom = 8

// ToplevelStateSuspended
const ToplevelStateSuspended = 9

// ToplevelWmCapabilitiesWindowMenu means show_window_menu is available
const ToplevelWmCapabilitiesWindowMenu = 1

// ToplevelWmCapabilitiesMaximize means set_maximized and unset_maximized are available
const ToplevelWmCapabilitiesMaximize = 2

// ToplevelWmCapabilitiesFullscreen means set_fullscreen and unset_fullscreen are available
const ToplevelWmCapabilitiesFullscreen = 3

// ToplevelWmCapabilitiesMinimize means set_minimized is available
const ToplevelWmCapabilitiesMinimize = 4

// PopupErrorInvalidGrab means tried to grab after being mapped
const PopupErrorInvalidGrab = 0

// WmBase create desktop-style surfaces
type WmBase struct {
	BaseProxy
	mu                 sync.RWMutex
	privateWmBasePings []WmBasePingHandler
}

// NewWmBase is a constructor for the WmBase object
func NewWmBase(ctx *Context) *WmBase {
	ret := new(WmBase)
	ctx.Register(ret)
	return ret
}

// Destroydestroy xdg_wm_base
func (p *WmBase) Destroy() error {

	return p.Context().SendRequest(p, 0)
}

// CreatePositionercreate a positioner object
func (p *WmBase) CreatePositioner() (*Positioner, error) {
	retId := NewPositioner(p.Context())
	return retId, p.Context().SendRequest(p, 1, retId)
}

// GetSurfacecreate a shell surface from a surface
func (p *WmBase) GetSurface(Surface *WlSurface) (*Surface, error) {
	retId := NewSurface(p.Context())
	return retId, p.Context().SendRequest(p, 2, retId, Surface)
}

// Pongrespond to a ping event
func (p *WmBase) Pong(Serial uint32) error {

	return p.Context().SendRequest(p, 3, Serial)
}

// Dispatch dispatches event for object WmBase
func (p *WmBase) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateWmBasePings) > 0 {
			ev := WmBasePingEvent{}
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privateWmBasePings {
				h.HandleWmBasePing(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// WmBasePingEvent is the check if the client is alive
type WmBasePingEvent struct {
	// Serial is the pass this to the pong request
	Serial uint32
}

// WmBasePingHandler is the handler interface for WmBasePingEvent
type WmBasePingHandler interface {
	HandleWmBasePing(WmBasePingEvent)
}

// AddPingHandler removes the Ping handler
func (p *WmBase) AddPingHandler(h WmBasePingHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateWmBasePings = append(p.privateWmBasePings, h)
		p.mu.Unlock()
	}
}

// RemovePingHandler adds the Ping handler
func (p *WmBase) RemovePingHandler(h WmBasePingHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateWmBasePings {
		if e == h {
			p.privateWmBasePings = append(p.privateWmBasePings[:i], p.privateWmBasePings[i+1:]...)
			break
		}
	}
}

// Positioner child surface positioner
type Positioner struct {
	BaseProxy
}

// NewPositioner is a constructor for the Positioner object
func NewPositioner(ctx *Context) *Positioner {
	ret := new(Positioner)
	ctx.Register(ret)
	return ret
}

// Destroydestroy the xdg_positioner object
func (p *Positioner) Destroy() error {

	return p.Context().SendRequest(p, 0)
}

// SetSizeset the size of the to-be positioned rectangle
func (p *Positioner) SetSize(Width int32, Height int32) error {

	return p.Context().SendRequest(p, 1, Width, Height)
}

// SetAnchorRectset the anchor rectangle within the parent surface
func (p *Positioner) SetAnchorRect(X int32, Y int32, Width int32, Height int32) error {

	return p.Context().SendRequest(p, 2, X, Y, Width, Height)
}

// SetAnchorset anchor rectangle anchor
func (p *Positioner) SetAnchor(Anchor uint32) error {

	return p.Context().SendRequest(p, 3, Anchor)
}

// SetGravityset child surface gravity
func (p *Positioner) SetGravity(Gravity uint32) error {

	return p.Context().SendRequest(p, 4, Gravity)
}

// SetConstraintAdjustmentset the adjustment to be done when constrained
func (p *Positioner) SetConstraintAdjustment(ConstraintAdjustment uint32) error {

	return p.Context().SendRequest(p, 5, ConstraintAdjustment)
}

// SetOffsetset surface position offset
func (p *Positioner) SetOffset(X int32, Y int32) error {

	return p.Context().SendRequest(p, 6, X, Y)
}

// SetReactivecontinuously reconstrain the surface
func (p *Positioner) SetReactive() error {

	return p.Context().SendRequest(p, 7)
}

// SetParentSize
func (p *Positioner) SetParentSize(ParentWidth int32, ParentHeight int32) error {

	return p.Context().SendRequest(p, 8, ParentWidth, ParentHeight)
}

// SetParentConfigureset parent configure this is a response to
func (p *Positioner) SetParentConfigure(Serial uint32) error {

	return p.Context().SendRequest(p, 9, Serial)
}

// Dispatch dispatches event for object Positioner
func (p *Positioner) Dispatch(event *Event) {
	switch event.Opcode {

	}
}

// Surface desktop user interface surface base interface
type Surface struct {
	BaseProxy
	mu                       sync.RWMutex
	privateSurfaceConfigures []SurfaceConfigureHandler
}

// NewSurface is a constructor for the Surface object
func NewSurface(ctx *Context) *Surface {
	ret := new(Surface)
	ctx.Register(ret)
	return ret
}

// Destroydestroy the xdg_surface
func (p *Surface) Destroy() error {

	return p.Context().SendRequest(p, 0)
}

// GetToplevelassign the xdg_toplevel surface role
func (p *Surface) GetToplevel() (*Toplevel, error) {
	retId := NewToplevel(p.Context())
	return retId, p.Context().SendRequest(p, 1, retId)
}

// GetPopupassign the xdg_popup surface role
func (p *Surface) GetPopup(Parent *Surface, Positioner *Positioner) (*Popup, error) {
	retId := NewPopup(p.Context())
	return retId, p.Context().SendRequest(p, 2, retId, Parent, Positioner)
}

// SetWindowGeometryset the new window geometry
func (p *Surface) SetWindowGeometry(X int32, Y int32, Width int32, Height int32) error {

	return p.Context().SendRequest(p, 3, X, Y, Width, Height)
}

// AckConfigureack a configure event
func (p *Surface) AckConfigure(Serial uint32) error {

	return p.Context().SendRequest(p, 4, Serial)
}

// Dispatch dispatches event for object Surface
func (p *Surface) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateSurfaceConfigures) > 0 {
			ev := SurfaceConfigureEvent{}
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privateSurfaceConfigures {
				h.HandleSurfaceConfigure(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// SurfaceConfigureEvent is the suggest a surface change
type SurfaceConfigureEvent struct {
	// Serial is the serial of the configure event
	Serial uint32
}

// SurfaceConfigureHandler is the handler interface for SurfaceConfigureEvent
type SurfaceConfigureHandler interface {
	HandleSurfaceConfigure(SurfaceConfigureEvent)
}

// AddConfigureHandler removes the Configure handler
func (p *Surface) AddConfigureHandler(h SurfaceConfigureHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateSurfaceConfigures = append(p.privateSurfaceConfigures, h)
		p.mu.Unlock()
	}
}

// RemoveConfigureHandler adds the Configure handler
func (p *Surface) RemoveConfigureHandler(h SurfaceConfigureHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateSurfaceConfigures {
		if e == h {
			p.privateSurfaceConfigures = append(p.privateSurfaceConfigures[:i], p.privateSurfaceConfigures[i+1:]...)
			break
		}
	}
}

// Toplevel toplevel surface
type Toplevel struct {
	BaseProxy
	mu                              sync.RWMutex
	privateToplevelConfigures       []ToplevelConfigureHandler
	privateToplevelCloses           []ToplevelCloseHandler
	privateToplevelConfigureBoundss []ToplevelConfigureBoundsHandler
	privateToplevelWmCapabilitiess  []ToplevelWmCapabilitiesHandler
}

// NewToplevel is a constructor for the Toplevel object
func NewToplevel(ctx *Context) *Toplevel {
	ret := new(Toplevel)
	ctx.Register(ret)
	return ret
}

// Destroydestroy the xdg_toplevel
func (p *Toplevel) Destroy() error {

	return p.Context().SendRequest(p, 0)
}

// SetParentset the parent of this surface
func (p *Toplevel) SetParent(Parent *Toplevel) error {

	return p.Context().SendRequest(p, 1, Parent)
}

// SetTitleset surface title
func (p *Toplevel) SetTitle(Title string) error {

	return p.Context().SendRequest(p, 2, Title)
}

// SetAppIdset application ID
func (p *Toplevel) SetAppId(AppId string) error {

	return p.Context().SendRequest(p, 3, AppId)
}

// ShowWindowMenushow the window menu
func (p *Toplevel) ShowWindowMenu(Seat *Seat, Serial uint32, X int32, Y int32) error {

	return p.Context().SendRequest(p, 4, Seat, Serial, X, Y)
}

// Movestart an interactive move
func (p *Toplevel) Move(Seat *Seat, Serial uint32) error {

	return p.Context().SendRequest(p, 5, Seat, Serial)
}

// Resizestart an interactive resize
func (p *Toplevel) Resize(Seat *Seat, Serial uint32, Edges uint32) error {

	return p.Context().SendRequest(p, 6, Seat, Serial, Edges)
}

// SetMaxSizeset the maximum size
func (p *Toplevel) SetMaxSize(Width int32, Height int32) error {

	return p.Context().SendRequest(p, 7, Width, Height)
}

// SetMinSizeset the minimum size
func (p *Toplevel) SetMinSize(Width int32, Height int32) error {

	return p.Context().SendRequest(p, 8, Width, Height)
}

// SetMaximizedmaximize the window
func (p *Toplevel) SetMaximized() error {

	return p.Context().SendRequest(p, 9)
}

// UnsetMaximizedunmaximize the window
func (p *Toplevel) UnsetMaximized() error {

	return p.Context().SendRequest(p, 10)
}

// SetFullscreenset the window as fullscreen on an output
func (p *Toplevel) SetFullscreen(Output *Output) error {

	return p.Context().SendRequest(p, 11, Output)
}

// UnsetFullscreenunset the window as fullscreen
func (p *Toplevel) UnsetFullscreen() error {

	return p.Context().SendRequest(p, 12)
}

// SetMinimizedset the window as minimized
func (p *Toplevel) SetMinimized() error {

	return p.Context().SendRequest(p, 13)
}

// Dispatch dispatches event for object Toplevel
func (p *Toplevel) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateToplevelConfigures) > 0 {
			ev := ToplevelConfigureEvent{}
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			ev.States = event.Array()
			p.mu.RLock()
			for _, h := range p.privateToplevelConfigures {
				h.HandleToplevelConfigure(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateToplevelCloses) > 0 {
			ev := ToplevelCloseEvent{}
			p.mu.RLock()
			for _, h := range p.privateToplevelCloses {
				h.HandleToplevelClose(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateToplevelConfigureBoundss) > 0 {
			ev := ToplevelConfigureBoundsEvent{}
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.privateToplevelConfigureBoundss {
				h.HandleToplevelConfigureBounds(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.privateToplevelWmCapabilitiess) > 0 {
			ev := ToplevelWmCapabilitiesEvent{}
			ev.Capabilities = event.Array()
			p.mu.RLock()
			for _, h := range p.privateToplevelWmCapabilitiess {
				h.HandleToplevelWmCapabilities(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// ToplevelConfigureEvent is the suggest a surface change
type ToplevelConfigureEvent struct {
	// Width is the
	Width int32
	// Height is the
	Height int32
	// States is the
	States []int32
}

// ToplevelCloseEvent is the surface wants to be closed
type ToplevelCloseEvent struct {
}

// ToplevelConfigureBoundsEvent is the recommended window geometry bounds
type ToplevelConfigureBoundsEvent struct {
	// Width is the
	Width int32
	// Height is the
	Height int32
}

// ToplevelWmCapabilitiesEvent is the compositor capabilities
type ToplevelWmCapabilitiesEvent struct {
	// Capabilities is the array of 32-bit capabilities
	Capabilities []int32
}

// ToplevelConfigureHandler is the handler interface for ToplevelConfigureEvent
type ToplevelConfigureHandler interface {
	HandleToplevelConfigure(ToplevelConfigureEvent)
}

// AddConfigureHandler removes the Configure handler
func (p *Toplevel) AddConfigureHandler(h ToplevelConfigureHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateToplevelConfigures = append(p.privateToplevelConfigures, h)
		p.mu.Unlock()
	}
}

// RemoveConfigureHandler adds the Configure handler
func (p *Toplevel) RemoveConfigureHandler(h ToplevelConfigureHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateToplevelConfigures {
		if e == h {
			p.privateToplevelConfigures = append(p.privateToplevelConfigures[:i], p.privateToplevelConfigures[i+1:]...)
			break
		}
	}
}

// ToplevelCloseHandler is the handler interface for ToplevelCloseEvent
type ToplevelCloseHandler interface {
	HandleToplevelClose(ToplevelCloseEvent)
}

// AddCloseHandler removes the Close handler
func (p *Toplevel) AddCloseHandler(h ToplevelCloseHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateToplevelCloses = append(p.privateToplevelCloses, h)
		p.mu.Unlock()
	}
}

// RemoveCloseHandler adds the Close handler
func (p *Toplevel) RemoveCloseHandler(h ToplevelCloseHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateToplevelCloses {
		if e == h {
			p.privateToplevelCloses = append(p.privateToplevelCloses[:i], p.privateToplevelCloses[i+1:]...)
			break
		}
	}
}

// ToplevelConfigureBoundsHandler is the handler interface for ToplevelConfigureBoundsEvent
type ToplevelConfigureBoundsHandler interface {
	HandleToplevelConfigureBounds(ToplevelConfigureBoundsEvent)
}

// AddConfigureBoundsHandler removes the ConfigureBounds handler
func (p *Toplevel) AddConfigureBoundsHandler(h ToplevelConfigureBoundsHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateToplevelConfigureBoundss = append(p.privateToplevelConfigureBoundss, h)
		p.mu.Unlock()
	}
}

// RemoveConfigureBoundsHandler adds the ConfigureBounds handler
func (p *Toplevel) RemoveConfigureBoundsHandler(h ToplevelConfigureBoundsHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateToplevelConfigureBoundss {
		if e == h {
			p.privateToplevelConfigureBoundss = append(p.privateToplevelConfigureBoundss[:i], p.privateToplevelConfigureBoundss[i+1:]...)
			break
		}
	}
}

// ToplevelWmCapabilitiesHandler is the handler interface for ToplevelWmCapabilitiesEvent
type ToplevelWmCapabilitiesHandler interface {
	HandleToplevelWmCapabilities(ToplevelWmCapabilitiesEvent)
}

// AddWmCapabilitiesHandler removes the WmCapabilities handler
func (p *Toplevel) AddWmCapabilitiesHandler(h ToplevelWmCapabilitiesHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateToplevelWmCapabilitiess = append(p.privateToplevelWmCapabilitiess, h)
		p.mu.Unlock()
	}
}

// RemoveWmCapabilitiesHandler adds the WmCapabilities handler
func (p *Toplevel) RemoveWmCapabilitiesHandler(h ToplevelWmCapabilitiesHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateToplevelWmCapabilitiess {
		if e == h {
			p.privateToplevelWmCapabilitiess = append(p.privateToplevelWmCapabilitiess[:i], p.privateToplevelWmCapabilitiess[i+1:]...)
			break
		}
	}
}

// Popup short-lived, popup surfaces for menus
type Popup struct {
	BaseProxy
	mu                        sync.RWMutex
	privatePopupConfigures    []PopupConfigureHandler
	privatePopupPopupDones    []PopupPopupDoneHandler
	privatePopupRepositioneds []PopupRepositionedHandler
}

// NewPopup is a constructor for the Popup object
func NewPopup(ctx *Context) *Popup {
	ret := new(Popup)
	ctx.Register(ret)
	return ret
}

// Destroyremove xdg_popup interface
func (p *Popup) Destroy() error {

	return p.Context().SendRequest(p, 0)
}

// Grabmake the popup take an explicit grab
func (p *Popup) Grab(Seat *Seat, Serial uint32) error {

	return p.Context().SendRequest(p, 1, Seat, Serial)
}

// Repositionrecalculate the popup's location
func (p *Popup) Reposition(Positioner *Positioner, Token uint32) error {

	return p.Context().SendRequest(p, 2, Positioner, Token)
}

// Dispatch dispatches event for object Popup
func (p *Popup) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privatePopupConfigures) > 0 {
			ev := PopupConfigureEvent{}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.privatePopupConfigures {
				h.HandlePopupConfigure(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privatePopupPopupDones) > 0 {
			ev := PopupPopupDoneEvent{}
			p.mu.RLock()
			for _, h := range p.privatePopupPopupDones {
				h.HandlePopupPopupDone(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privatePopupRepositioneds) > 0 {
			ev := PopupRepositionedEvent{}
			ev.Token = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privatePopupRepositioneds {
				h.HandlePopupRepositioned(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// PopupConfigureEvent is the configure the popup surface
type PopupConfigureEvent struct {
	// X is the x position relative to parent surface window geometry
	X int32
	// Y is the y position relative to parent surface window geometry
	Y int32
	// Width is the window geometry width
	Width int32
	// Height is the window geometry height
	Height int32
}

// PopupPopupDoneEvent is the popup interaction is done
type PopupPopupDoneEvent struct {
}

// PopupRepositionedEvent is the signal the completion of a repositioned request
type PopupRepositionedEvent struct {
	// Token is the reposition request token
	Token uint32
}

// PopupConfigureHandler is the handler interface for PopupConfigureEvent
type PopupConfigureHandler interface {
	HandlePopupConfigure(PopupConfigureEvent)
}

// AddConfigureHandler removes the Configure handler
func (p *Popup) AddConfigureHandler(h PopupConfigureHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePopupConfigures = append(p.privatePopupConfigures, h)
		p.mu.Unlock()
	}
}

// RemoveConfigureHandler adds the Configure handler
func (p *Popup) RemoveConfigureHandler(h PopupConfigureHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privatePopupConfigures {
		if e == h {
			p.privatePopupConfigures = append(p.privatePopupConfigures[:i], p.privatePopupConfigures[i+1:]...)
			break
		}
	}
}

// PopupPopupDoneHandler is the handler interface for PopupPopupDoneEvent
type PopupPopupDoneHandler interface {
	HandlePopupPopupDone(PopupPopupDoneEvent)
}

// AddPopupDoneHandler removes the PopupDone handler
func (p *Popup) AddPopupDoneHandler(h PopupPopupDoneHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePopupPopupDones = append(p.privatePopupPopupDones, h)
		p.mu.Unlock()
	}
}

// RemovePopupDoneHandler adds the PopupDone handler
func (p *Popup) RemovePopupDoneHandler(h PopupPopupDoneHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privatePopupPopupDones {
		if e == h {
			p.privatePopupPopupDones = append(p.privatePopupPopupDones[:i], p.privatePopupPopupDones[i+1:]...)
			break
		}
	}
}

// PopupRepositionedHandler is the handler interface for PopupRepositionedEvent
type PopupRepositionedHandler interface {
	HandlePopupRepositioned(PopupRepositionedEvent)
}

// AddRepositionedHandler removes the Repositioned handler
func (p *Popup) AddRepositionedHandler(h PopupRepositionedHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePopupRepositioneds = append(p.privatePopupRepositioneds, h)
		p.mu.Unlock()
	}
}

// RemoveRepositionedHandler adds the Repositioned handler
func (p *Popup) RemoveRepositionedHandler(h PopupRepositionedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privatePopupRepositioneds {
		if e == h {
			p.privatePopupRepositioneds = append(p.privatePopupRepositioneds[:i], p.privatePopupRepositioneds[i+1:]...)
			break
		}
	}
}
